import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from scipy.spatial import KDTree
import logging
import json
import os
import re

logger = logging.getLogger("Visualizer")

class InterfaceVisualizer:
    def __init__(self, chain_A_atoms, chain_A_coords, chain_B_coords, chain_B_atoms=None, 
                 pdb_file=None, chain_a_id=None, chain_b_id=None, arpeggio_file=None):
        """
        Args:
            chain_A_atoms: List of Bio.PDB Atom objects for Chain A
            chain_A_coords: Numpy array (N,3) for Chain A
            chain_B_coords: Numpy array (M,3) for Chain B
            chain_B_atoms: List of Bio.PDB Atom objects for Chain B
            chain_a_id: Chain ID string for A (e.g. "A")
            chain_b_id: Chain ID string for B (e.g. "B")
            arpeggio_file: Path to the .json file generated by pdbe-arpeggio
        """
        self.atoms_A = chain_A_atoms
        self.coords_A = chain_A_coords
        self.coords_B = chain_B_coords
        self.atoms_B = chain_B_atoms
        
        # Only build tree if we don't have external interaction data
        self.tree_B = KDTree(self.coords_B) if not arpeggio_file else None
        self.artist_map = {}

        # Ensure IDs are stripped of whitespace for comparison
        self.chain_a_id = str(chain_a_id).strip() if chain_a_id else None
        self.chain_b_id = str(chain_b_id).strip() if chain_b_id else None

        # --- Interaction Categories (Arpeggio Specifics) ---
        self.interaction_types = [
            'default',      # <--- Renamed from 'vdw'
            'salt_bridge',
            'cation_pi',
            'pi_stack',     # pi-pi
            'hbond',
            'sulfur_pi',
            'hydrophobic',
            'halogen_bond',
            'metal_complex'
        ]
        
        self.interaction_colors = {
            'default': '#008080',       # <--- Teal (Nice Color) for default/vdw
            'salt_bridge': '#FFA500',   # Orange
            'cation_pi': '#FF4500',     # OrangeRed
            'pi_stack': '#8A2BE2',      # BlueViolet
            'hbond': '#0000FF',         # Blue
            'sulfur_pi': '#FFD700',     # Gold
            'hydrophobic': '#808080',   # Gray
            'halogen_bond': '#00CED1',  # DarkTurquoise
            'metal_complex': '#A52A2A'  # Brown
        }

        # --- Arpeggio Mapping ---
        # Maps raw Arpeggio 'interaction_type' to our canonical list
        self.arpeggio_mapping = {
            'salt_bridge': 'salt_bridge', 'ionic': 'salt_bridge', 
            'cation_pi': 'cation_pi', 'pi_cation': 'cation_pi',
            'pi_stack': 'pi_stack', 'pi_pi': 'pi_stack', 'amide_ring': 'pi_stack',
            'hbond': 'hbond', 'weak_hbond': 'hbond', 'polar': 'hbond', 'weak_polar': 'hbond',
            'xbond': 'halogen_bond', 'halogen_bond': 'halogen_bond',
            'sulfur_pi': 'sulfur_pi', 'pi_sulfur': 'sulfur_pi',
            'hydrophobic': 'hydrophobic', 'aromatic': 'hydrophobic',
            'metal_complex': 'metal_complex', 'covalent': 'metal_complex',
            
            # Map generic contacts to 'default'
            'vdw': 'default', 
            'vdw_clash': 'default', 
            'clash': 'default',
            'proximal': 'default',
            'atom-atom': 'default'
        }

        # Data store: { (res_seq, res_name): set([interaction_types]) }
        self.arpeggio_data = None
        
        if arpeggio_file and os.path.exists(arpeggio_file):
            self._load_arpeggio_data(arpeggio_file)
        elif arpeggio_file:
            logger.warning(f"Arpeggio file not found: {arpeggio_file}. Falling back to heuristics.")
            if self.tree_B is None: self.tree_B = KDTree(self.coords_B)

        # --- Fallback Chemical Definitions ---
        self.charged_pos = {'ARG', 'LYS', 'HIS'} 
        self.charged_neg = {'ASP', 'GLU'}
        self.aromatic = {'PHE', 'TYR', 'TRP', 'HIS'}
        self.hydrophobic = {'ALA', 'VAL', 'LEU', 'ILE', 'MET', 'PHE', 'TRP', 'PRO', 'CYS', 'TYR'}
        self.cation_atoms = {'NZ', 'NH1', 'NH2', 'ND1', 'NE2'} 
        self.anion_atoms = {'OD1', 'OD2', 'OE1', 'OE2', 'OXT'} 
        self.polar_atoms = {'N', 'O', 'S', 'F'}
        self.sulfur_atoms = {'SG', 'SD'}

    def _extract_seq_num(self, val):
        """Robustly extract integer sequence number from strings like '100', '100A'."""
        try:
            return int(val)
        except (ValueError, TypeError):
            match = re.match(r"^(-?\d+)", str(val))
            if match:
                return int(match.group(1))
            return None

    def _load_arpeggio_data(self, json_path):
        """
        Parses PDBe-Arpeggio JSON output with comprehensive debugging.
        """
        try:
            with open(json_path, 'r') as f:
                data = json.load(f)
            
            temp_data = {}
            count = 0
            seen_pairs = set()
            found_raw_types = set() 
            
            interactions = data if isinstance(data, list) else data.get('interactions', [])

            for item in interactions:
                bgn = item.get("bgn", {})
                end = item.get("end", {})
                
                c1 = bgn.get("auth_asym_id", "").strip()
                c2 = end.get("auth_asym_id", "").strip()
                
                if c1 and c2:
                    if c1 > c2: seen_pairs.add((c2, c1))
                    else: seen_pairs.add((c1, c2))
                
                pair = {c1, c2}
                target_pair = {self.chain_a_id, self.chain_b_id}
                
                if pair != target_pair:
                    continue
                
                if c1 == self.chain_a_id:
                    res_info = bgn
                else:
                    res_info = end
                
                raw_seq = res_info.get("auth_seq_id")
                res_seq = self._extract_seq_num(raw_seq)
                if res_seq is None:
                    continue
                
                raw_type = item.get("type") 
                if isinstance(raw_type, list): raw_types = raw_type
                else: raw_types = [raw_type]

                mapped_types = set()
                for rt in raw_types:
                    found_raw_types.add(rt)
                    mapped = self.arpeggio_mapping.get(rt)
                    if mapped:
                        mapped_types.add(mapped)
                
                if not mapped_types: continue

                key = res_seq
                if key not in temp_data: temp_data[key] = set()
                temp_data[key].update(mapped_types)
                count += 1
            
            if count == 0:
                print("\n" + "="*50)
                print("[DEBUG] Arpeggio loaded 0 interactions.")
                print(f"[DEBUG] User requested: Chain '{self.chain_a_id}' vs Chain '{self.chain_b_id}'")
                print(f"[DEBUG] Pairs found in JSON: {list(seen_pairs)}")
                print(f"[DEBUG] Types found for A-B pair (but maybe unmapped): {list(found_raw_types)}")
                print("="*50 + "\n")
                
                logger.warning("Falling back to geometric heuristics.")
                self.arpeggio_data = None
                if self.tree_B is None: self.tree_B = KDTree(self.coords_B)
            else:
                logger.info(f"Loaded {count} Arpeggio interactions for Chain {self.chain_a_id}.")
                self.arpeggio_data = temp_data
            
        except Exception as e:
            logger.error(f"Failed to load Arpeggio JSON: {e}")
            self.arpeggio_data = None 
            if self.tree_B is None: self.tree_B = KDTree(self.coords_B)

    def _get_interaction_type_heuristic(self, atom_A, atom_B, dist):
        if dist > 6.0: return None
        
        res_A = atom_A.get_parent().get_resname()
        res_B = atom_B.get_parent().get_resname()
        name_A = atom_A.get_name()
        name_B = atom_B.get_name()
        elem_A = atom_A.element.upper()
        elem_B = atom_B.element.upper()
        
        is_ani_A = ((res_A in self.charged_neg and name_A in self.anion_atoms) or name_A == 'OXT')
        is_ani_B = ((res_B in self.charged_neg and name_B in self.anion_atoms) or name_B == 'OXT')
        is_cat_A = (res_A in self.charged_pos and name_A in self.cation_atoms)
        is_cat_B = (res_B in self.charged_pos and name_B in self.cation_atoms)
        is_aro_A = (res_A in self.aromatic and name_A not in ['CA', 'C', 'O', 'N'])
        is_aro_B = (res_B in self.aromatic and name_B not in ['CA', 'C', 'O', 'N'])

        if dist < 5.0:
            if dist < 4.0 and ((is_cat_A and is_ani_B) or (is_ani_A and is_cat_B)): return 'salt_bridge'
            if is_aro_A or is_aro_B:
                if (is_aro_A and is_cat_B) or (is_cat_A and is_aro_B): return 'cation_pi'
            if (is_cat_A and is_ani_B) or (is_ani_A and is_cat_B): return 'salt_bridge'

        if dist < 3.8:
            if elem_A in self.polar_atoms and elem_B in self.polar_atoms: return 'hbond'
            if (elem_A == 'C' and elem_B in self.polar_atoms) or (elem_B == 'C' and elem_A in self.polar_atoms): return 'hbond'

        if dist < 4.5 and (is_aro_A or is_aro_B):
            if (is_aro_A and name_B in self.sulfur_atoms) or (name_A in self.sulfur_atoms and is_aro_B): return 'sulfur_pi'

        if dist < 5.5:
            if is_aro_A and is_aro_B: return 'pi_stack'
            if dist < 4.5:
                is_ali_A = (elem_A == 'C' and not is_aro_A and name_A not in ['CA', 'C'])
                is_ali_B = (elem_B == 'C' and not is_aro_B and name_B not in ['CA', 'C'])
                if (is_aro_A and is_ali_B) or (is_ali_A and is_aro_B): return 'hydrophobic'
            if dist < 4.5 and elem_A == 'C' and elem_B == 'C' and name_A not in ['CA', 'C'] and name_B not in ['CA', 'C']:
                 if (not is_aro_A) and (not is_aro_B): return 'hydrophobic'

        return None

    def plot_patches(self, patches, output_file=None, show=True, style_config=None):
        if not patches: return None
        self.artist_map = {}
        style = {
            'color': 'red', 'font_family': 'sans-serif', 'font_size': 9, 
            'color_by_type': False, 'active_types': self.interaction_types
        }
        if style_config: style.update(style_config)

        n_patches = len(patches)
        fig, axes = plt.subplots(1, n_patches, figsize=(5 * n_patches, 6))
        if n_patches == 1: axes = [axes]
        
        logger.info(f"Visualizing {n_patches} patches.")

        used_interactions = set()
        for i, patch in enumerate(patches):
            found = self._draw_single_patch(axes[i], patch, i+1, style)
            used_interactions.update(found)

        if style['color_by_type'] and used_interactions:
            legend_handles = []
            for t in self.interaction_types:
                if t in used_interactions:
                    legend_handles.append(mpatches.Patch(color=self.interaction_colors.get(t, 'gray'), label=t))
            fig.legend(handles=legend_handles, loc='upper center', ncol=min(len(legend_handles), 5), frameon=False)

        plt.tight_layout(rect=[0, 0, 1, 0.95])
        if output_file: plt.savefig(output_file, dpi=300)
        if show: plt.show()
        return fig

    def _draw_single_patch(self, ax, patch, patch_id, style):
        found_types = set()
        uv = patch.metadata.get('uv')
        if uv is None: return found_types

        ax.triplot(uv[:, 0], uv[:, 1], patch.faces, color='gray', alpha=0.15, lw=0.5, zorder=1)
        
        patch_tree = KDTree(patch.vertices)
        dists_A_to_patch, vertex_indices = patch_tree.query(self.coords_A)
        on_patch_mask = dists_A_to_patch < 3.0 
        
        if self.arpeggio_data is not None:
             candidate_indices = np.where(on_patch_mask)[0]
        else:
            if self.tree_B:
                dists_A_to_B_coarse, _ = self.tree_B.query(self.coords_A)
                interaction_mask = dists_A_to_B_coarse < 8.0
                candidate_indices = np.where(on_patch_mask & interaction_mask)[0]
            else:
                candidate_indices = []

        residue_data = {} 
        for idx in candidate_indices:
            atom_A = self.atoms_A[idx]
            parent = atom_A.get_parent()
            res_id = parent.get_id()
            res_seq = res_id[1]
            
            u, v = uv[vertex_indices[idx]]
            if res_id not in residue_data: residue_data[res_id] = {'uvs': [], 'types': set()}
            residue_data[res_id]['uvs'].append([u, v])
            
            if style['color_by_type']:
                if self.arpeggio_data is not None:
                    if res_seq in self.arpeggio_data:
                        residue_data[res_id]['types'].update(self.arpeggio_data[res_seq])
                else:
                    if self.atoms_B:
                        nearby_b_indices = self.tree_B.query_ball_point(self.coords_A[idx], r=6.0)
                        for b_idx in nearby_b_indices:
                            dist = np.linalg.norm(self.coords_A[idx] - self.coords_B[b_idx])
                            i_type = self._get_interaction_type_heuristic(atom_A, self.atoms_B[b_idx], dist)
                            if i_type: residue_data[res_id]['types'].add(i_type)

        for res_id, data in residue_data.items():
            uv_array = np.array(data['uvs'])
            u_center, v_center = np.mean(uv_array, axis=0)
            types = data['types']
            
            best_type = None
            if style['color_by_type']:
                active_list = style.get('active_types', [])
                if types:
                    best_rank = 999
                    for t in types:
                        if t not in active_list: continue
                        if t in self.interaction_types:
                            rank = self.interaction_types.index(t)
                            if rank < best_rank:
                                best_rank, best_type = rank, t
                
                if best_type is None: continue 
                final_color = self.interaction_colors.get(best_type, '#FFC0CB')
                found_types.add(best_type)
            else:
                final_color = style['color']

            chain_obj = self.atoms_A[0].get_parent().get_parent()
            try:
                res_obj = chain_obj[res_id]
                res_name = f"{res_obj.get_resname()}{res_id[1]}"
            except KeyError:
                 res_name = f"{res_id[1]}"

            uid = f"{patch_id}_{res_name}"
            
            sc = ax.scatter(u_center, v_center, c=final_color, s=80, edgecolors='white', zorder=10, picker=5)
            sc.set_gid(uid)
            txt = ax.text(u_center, v_center + 0.04, res_name, fontsize=style['font_size'], 
                          fontname=style['font_family'], ha='center', fontweight='bold', color='darkred', picker=True)
            txt.set_gid(uid)
            self.artist_map[uid] = {'scatter': sc, 'text': txt}

        ax.set_title(f"Patch {patch_id}")
        ax.set_aspect('equal')
        ax.axis('off')
        return found_types
