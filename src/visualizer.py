import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from scipy.spatial import KDTree
import logging
import json
import os

logger = logging.getLogger("Visualizer")

class InterfaceVisualizer:
    def __init__(self, chain_A_atoms, chain_A_coords, chain_B_coords, chain_B_atoms=None, 
                 pdb_file=None, chain_a_id=None, chain_b_id=None, arpeggio_file=None):
        """
        Args:
            chain_A_atoms: List of Bio.PDB Atom objects for Chain A
            chain_A_coords: Numpy array (N,3) for Chain A
            chain_B_coords: Numpy array (M,3) for Chain B
            chain_B_atoms: List of Bio.PDB Atom objects for Chain B
            chain_a_id: Chain ID string for A (e.g. "A")
            chain_b_id: Chain ID string for B (e.g. "B")
            arpeggio_file: Path to the .json file generated by pdbe-arpeggio
        """
        self.atoms_A = chain_A_atoms
        self.coords_A = chain_A_coords
        self.coords_B = chain_B_coords
        self.atoms_B = chain_B_atoms
        
        # Only build tree if we don't have external interaction data
        self.tree_B = KDTree(self.coords_B) if not arpeggio_file else None
        self.artist_map = {}

        # Identifiers for mapping Arpeggio data
        self.chain_a_id = chain_a_id
        self.chain_b_id = chain_b_id

        # --- Interaction Categories (Arpeggio Specifics) ---
        self.interaction_types = [
            'salt_bridge',
            'cation_pi',
            'pi_stack',     # pi-pi
            'hbond',
            'sulfur_pi',
            'hydrophobic',
            'halogen_bond',
            'metal_complex'
        ]
        
        self.interaction_colors = {
            'salt_bridge': '#FFA500',   # Orange
            'cation_pi': '#FF4500',     # OrangeRed
            'pi_stack': '#8A2BE2',      # BlueViolet
            'hbond': '#0000FF',         # Blue
            'sulfur_pi': '#FFD700',     # Gold
            'hydrophobic': '#808080',   # Gray
            'halogen_bond': '#00CED1',  # DarkTurquoise
            'metal_complex': '#A52A2A'  # Brown
        }

        # --- Arpeggio Mapping ---
        # Maps raw Arpeggio 'interaction_type' to our canonical list
        self.arpeggio_mapping = {
            # Ionic / Electrostatic
            'salt_bridge': 'salt_bridge',
            'ionic': 'salt_bridge', 
            
            # Cation-Pi
            'cation_pi': 'cation_pi',
            'pi_cation': 'cation_pi',
            
            # Pi-Stacking
            'pi_stack': 'pi_stack',
            'pi_pi': 'pi_stack',
            'amide_ring': 'pi_stack',
            
            # Hydrogen Bonds
            'hbond': 'hbond',
            'weak_hbond': 'hbond',
            
            # Halogen
            'xbond': 'halogen_bond',
            'halogen_bond': 'halogen_bond',
            
            # Sulfur-Pi
            'sulfur_pi': 'sulfur_pi',
            'pi_sulfur': 'sulfur_pi',
            
            # Hydrophobic
            'hydrophobic': 'hydrophobic',
            
            # Metal / Others
            'metal_complex': 'metal_complex',
            'covalent': 'metal_complex'
        }

        # Data store: { (res_seq, res_name): set([interaction_types]) }
        self.arpeggio_data = None
        
        if arpeggio_file and os.path.exists(arpeggio_file):
            self._load_arpeggio_data(arpeggio_file)
        elif arpeggio_file:
            logger.warning(f"Arpeggio file not found: {arpeggio_file}. Falling back to heuristics.")

        # --- Fallback Chemical Definitions (Used only if Arpeggio is missing) ---
        self.charged_pos = {'ARG', 'LYS', 'HIS'} 
        self.charged_neg = {'ASP', 'GLU'}
        self.aromatic = {'PHE', 'TYR', 'TRP', 'HIS'}
        self.hydrophobic = {'ALA', 'VAL', 'LEU', 'ILE', 'MET', 'PHE', 'TRP', 'PRO', 'CYS', 'TYR'}
        self.cation_atoms = {'NZ', 'NH1', 'NH2', 'ND1', 'NE2'} 
        self.anion_atoms = {'OD1', 'OD2', 'OE1', 'OE2', 'OXT'} 
        self.polar_atoms = {'N', 'O', 'S', 'F'}
        self.sulfur_atoms = {'SG', 'SD'}

    def _load_arpeggio_data(self, json_path):
        """
        Parses PDBe-Arpeggio JSON output.
        Stores interactions relevant to Chain A residues interacting with Chain B.
        """
        try:
            with open(json_path, 'r') as f:
                data = json.load(f)
            
            self.arpeggio_data = {}
            count = 0
            
            # Arpeggio JSON structure handling
            interactions = data if isinstance(data, list) else data.get('interactions', [])

            for item in interactions:
                bgn = item.get("bgn", {})
                end = item.get("end", {})
                
                c1 = bgn.get("auth_asym_id")
                c2 = end.get("auth_asym_id")
                
                # Check if this is an A-B interaction
                pair = {c1, c2}
                if pair != {self.chain_a_id, self.chain_b_id}:
                    continue
                
                # Identify which part is on Chain A (the surface we are plotting)
                if c1 == self.chain_a_id:
                    res_info = bgn
                else:
                    res_info = end
                
                try:
                    res_seq = int(res_info.get("auth_seq_id"))
                    # res_name = res_info.get("label_comp_id") 
                except (ValueError, TypeError):
                    continue
                
                # Map Arpeggio type to our category
                raw_type = item.get("type") 
                if isinstance(raw_type, list):
                    raw_types = raw_type
                else:
                    raw_types = [raw_type]

                mapped_types = set()
                for rt in raw_types:
                    mapped = self.arpeggio_mapping.get(rt)
                    if mapped:
                        mapped_types.add(mapped)
                
                if not mapped_types:
                    continue

                key = res_seq
                if key not in self.arpeggio_data:
                    self.arpeggio_data[key] = set()
                self.arpeggio_data[key].update(mapped_types)
                count += 1
                
            logger.info(f"Loaded {count} Arpeggio interactions for Chain {self.chain_a_id}.")
            
        except Exception as e:
            logger.error(f"Failed to load Arpeggio JSON: {e}")
            self.arpeggio_data = None # Trigger fallback

    def _get_interaction_type_heuristic(self, atom_A, atom_B, dist):
        """
        Fallback classification logic, updated to return specific Arpeggio-like types.
        """
        if dist > 6.0: return None
        
        res_A = atom_A.get_parent().get_resname()
        res_B = atom_B.get_parent().get_resname()
        name_A = atom_A.get_name()
        name_B = atom_B.get_name()
        elem_A = atom_A.element.upper()
        elem_B = atom_B.element.upper()
        
        is_ani_A = ((res_A in self.charged_neg and name_A in self.anion_atoms) or name_A == 'OXT')
        is_ani_B = ((res_B in self.charged_neg and name_B in self.anion_atoms) or name_B == 'OXT')
        is_cat_A = (res_A in self.charged_pos and name_A in self.cation_atoms)
        is_cat_B = (res_B in self.charged_pos and name_B in self.cation_atoms)
        is_aro_A = (res_A in self.aromatic and name_A not in ['CA', 'C', 'O', 'N'])
        is_aro_B = (res_B in self.aromatic and name_B not in ['CA', 'C', 'O', 'N'])

        # 1. Electrostatic / Salt Bridge / Cation-Pi
        if dist < 5.0:
            # Salt Bridge (< 4.0A)
            if dist < 4.0 and ((is_cat_A and is_ani_B) or (is_ani_A and is_cat_B)):
                return 'salt_bridge'
            # Cation-Pi (< 5.0A)
            if is_aro_A or is_aro_B:
                if (is_aro_A and is_cat_B) or (is_cat_A and is_aro_B):
                    return 'cation_pi'
            # General Attractive Charge -> default to salt_bridge
            if (is_cat_A and is_ani_B) or (is_ani_A and is_cat_B):
                return 'salt_bridge'

        # 2. Hydrogen Bond
        if dist < 3.8:
            if elem_A in self.polar_atoms and elem_B in self.polar_atoms:
                return 'hbond'
            if (elem_A == 'C' and elem_B in self.polar_atoms) or (elem_B == 'C' and elem_A in self.polar_atoms):
                return 'hbond'

        # 3. Pi-Sulfur
        if dist < 4.5 and (is_aro_A or is_aro_B):
            if (is_aro_A and name_B in self.sulfur_atoms) or (name_A in self.sulfur_atoms and is_aro_B):
                return 'sulfur_pi'

        # 4. Hydrophobic / Pi-Stack
        if dist < 5.5:
            # Pi-Stacking
            if is_aro_A and is_aro_B:
                return 'pi_stack'
            
            # Hydrophobic checks
            if dist < 4.5:
                is_aliphatic_A = (elem_A == 'C' and not is_aro_A and name_A not in ['CA', 'C'])
                is_aliphatic_B = (elem_B == 'C' and not is_aro_B and name_B not in ['CA', 'C'])
                if (is_aro_A and is_aliphatic_B) or (is_aliphatic_A and is_aro_B):
                    return 'hydrophobic'

            if dist < 4.5 and elem_A == 'C' and elem_B == 'C':
                if name_A not in ['CA', 'C'] and name_B not in ['CA', 'C']:
                    is_aliphatic_A = (elem_A == 'C' and not is_aro_A)
                    is_aliphatic_B = (elem_B == 'C' and not is_aro_B)
                    if is_aliphatic_A and is_aliphatic_B:
                        return 'hydrophobic'
                    if res_A in self.hydrophobic and res_B in self.hydrophobic:
                        return 'hydrophobic'

        return None

    def plot_patches(self, patches, output_file=None, show=True, style_config=None):
        if not patches:
            return None
        
        self.artist_map = {}
        style = {
            'color': 'red', 'font_family': 'sans-serif', 'font_size': 9, 
            'color_by_type': False, 'active_types': self.interaction_types
        }
        if style_config: style.update(style_config)

        n_patches = len(patches)
        fig, axes = plt.subplots(1, n_patches, figsize=(5 * n_patches, 6))
        if n_patches == 1: axes = [axes]
        
        logger.info(f"Visualizing {n_patches} patches.")

        used_interactions = set()
        for i, patch in enumerate(patches):
            found = self._draw_single_patch(axes[i], patch, i+1, style)
            used_interactions.update(found)

        if style['color_by_type'] and used_interactions:
            legend_handles = []
            for t in self.interaction_types:
                if t in used_interactions:
                    legend_handles.append(mpatches.Patch(color=self.interaction_colors.get(t, 'gray'), label=t))
            fig.legend(handles=legend_handles, loc='upper center', ncol=min(len(legend_handles), 5), frameon=False)

        plt.tight_layout(rect=[0, 0, 1, 0.95])
        if output_file: plt.savefig(output_file, dpi=300)
        if show: plt.show()
        return fig

    def _draw_single_patch(self, ax, patch, patch_id, style):
        found_types = set()
        uv = patch.metadata.get('uv')
        if uv is None: return found_types

        ax.triplot(uv[:, 0], uv[:, 1], patch.faces, color='gray', alpha=0.15, lw=0.5, zorder=1)
        
        patch_tree = KDTree(patch.vertices)
        dists_A_to_patch, vertex_indices = patch_tree.query(self.coords_A)
        on_patch_mask = dists_A_to_patch < 3.0 
        
        # Identify residues on this patch
        if self.arpeggio_data is not None:
             # STRATEGY A: Using Arpeggio Data (Fast lookups)
             candidate_indices = np.where(on_patch_mask)[0]
        else:
            # STRATEGY B: Legacy Heuristic (Geometric query)
            if self.tree_B:
                dists_A_to_B_coarse, _ = self.tree_B.query(self.coords_A)
                interaction_mask = dists_A_to_B_coarse < 8.0
                candidate_indices = np.where(on_patch_mask & interaction_mask)[0]
            else:
                candidate_indices = []

        residue_data = {} 
        
        for idx in candidate_indices:
            atom_A = self.atoms_A[idx]
            parent = atom_A.get_parent()
            res_id = parent.get_id() # (hetero, seq, ins)
            res_seq = res_id[1]      # integer sequence number
            
            u, v = uv[vertex_indices[idx]]
            
            if res_id not in residue_data: residue_data[res_id] = {'uvs': [], 'types': set()}
            residue_data[res_id]['uvs'].append([u, v])
            
            if style['color_by_type']:
                if self.arpeggio_data is not None:
                    # Lookup from Arpeggio
                    if res_seq in self.arpeggio_data:
                        residue_data[res_id]['types'].update(self.arpeggio_data[res_seq])
                else:
                    # Calculate on the fly (Heuristic)
                    if self.atoms_B:
                        nearby_b_indices = self.tree_B.query_ball_point(self.coords_A[idx], r=6.0)
                        for b_idx in nearby_b_indices:
                            dist = np.linalg.norm(self.coords_A[idx] - self.coords_B[b_idx])
                            i_type = self._get_interaction_type_heuristic(atom_A, self.atoms_B[b_idx], dist)
                            if i_type: residue_data[res_id]['types'].add(i_type)

        for res_id, data in residue_data.items():
            uv_array = np.array(data['uvs'])
            u_center, v_center = np.mean(uv_array, axis=0)
            types = data['types']
            
            best_type = None
            if style['color_by_type']:
                active_list = style.get('active_types', [])
                if types:
                    best_rank = 999
                    for t in types:
                        if t not in active_list: continue
                        if t in self.interaction_types:
                            rank = self.interaction_types.index(t)
                            if rank < best_rank:
                                best_rank, best_type = rank, t
                
                if best_type is None: continue 
                final_color = self.interaction_colors.get(best_type, '#FFC0CB')
                found_types.add(best_type)
            else:
                final_color = style['color']

            # Corrected logic here:
            chain_obj = self.atoms_A[0].get_parent().get_parent()
            # Directly access residue by ID from the chain object
            res_obj = chain_obj[res_id]
            res_name = f"{res_obj.get_resname()}{res_id[1]}"
            uid = f"{patch_id}_{res_name}"
            
            sc = ax.scatter(u_center, v_center, c=final_color, s=80, edgecolors='white', zorder=10, picker=5)
            sc.set_gid(uid)
            txt = ax.text(u_center, v_center + 0.04, res_name, fontsize=style['font_size'], 
                          fontname=style['font_family'], ha='center', fontweight='bold', color='darkred', picker=True)
            txt.set_gid(uid)
            self.artist_map[uid] = {'scatter': sc, 'text': txt}

        ax.set_title(f"Patch {patch_id}")
        ax.set_aspect('equal')
        ax.axis('off')
        return found_types
